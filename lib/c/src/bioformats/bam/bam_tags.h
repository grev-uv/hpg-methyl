/**
 * bam_tags.h
 * - Date: 30 / Jan / 2017
 * - Who: Cesar Gonzalez (Cesar.Gonzalez-Segura@uv.es)
 *
 * This module is used to operate with BAM alignment tags. It can
 * create, modify and erase individual tags, as well as encoding
 * them into a BAM alignment or decode them from an existing
 * alignment.
 *
 */

#ifndef BAM_TAGS_H
#define BAM_TAGS_H

#include <stdint.h>
#include <stdlib.h>

#include "containers/array_list.h"

// BAM tag data types
#define BAM_TAG_TYPE_CHAR         'A'
typedef char bam_char_t;

#define BAM_TAG_TYPE_BYTE         'c'
typedef int8_t bam_byte_t;

#define BAM_TAG_TYPE_UBYTE        'C'
typedef uint8_t bam_ubyte_t;

#define BAM_TAG_TYPE_SHORT        's'
typedef int16_t bam_short_t;

#define BAM_TAG_TYPE_USHORT       'S'
typedef uint16_t bam_ushort_t;

#define BAM_TAG_TYPE_INT          'i'
typedef int32_t bam_int_t;

#define BAM_TAG_TYPE_UINT         'I'
typedef uint32_t bam_uint_t;

#define BAM_TAG_TYPE_FLOAT        'f'
typedef float bam_float_t;

#define BAM_TAG_TYPE_STRING       'Z'
typedef struct bam_string {
  char *data;
  size_t length;
  size_t count;
} bam_string_t;

#define BAM_TAG_TYPE_HEX_STRING   'H'
typedef bam_string_t bam_hex_string_t;

#define BAM_TAG_TYPE_BINARY       'B'
typedef struct bam_binary_array {
  char type;
  uint32_t length;
  size_t count;
  void *data;
} bam_binary_array_t;

// Values for the Bismark proprietary tags
#define XM_TAG_NAME       "XM" /**< Methylation status */
#define XG_TAG_NAME       "XG" /**< Alignment conversion state */
#define XR_TAG_NAME       "XR" /**< Read conversion state */

// Values for the SAM standard tags
#define AM_TAG_NAME       "AM" /**< Smallest template-independent mapping quality of segments in the rest */
#define AS_TAG_NAME       "AS" /**< Alignment score generated by the aligner */
#define BC_TAG_NAME       "BC" /**< Barcode sequence */
#define BQ_TAG_NAME       "BQ" /**< Offset to the base alignment quality */
#define CC_TAG_NAME       "CC" /**< Reference name of the next hit */
#define CM_TAG_NAME       "CM" /**< Edit distance between the color sequence and the color reference */
#define CO_TAG_NAME       "CO" /**< Free-text comment */
#define CP_TAG_NAME       "CP" /**< Left-most coordinate of the next hit */
#define CQ_TAG_NAME       "CQ" /**< Color read base qualities */
#define CS_TAG_NAME       "CS" /**< Color read sequence */
#define CT_TAG_NAME       "CT" /**< Complete read annotation */
#define NH_TAG_NAME       "NH" /**< Number of reported alignments that contain the query in the current record */
#define NM_TAG_NAME       "NM" /**< Edit distance to the reference */

// Values for the hydroximethylation proprietary tags
#define ZM_TAG_NAME               "ZM"

// Values for the Bismark SAM format methylation status
// information (XM)
#define XM_UNMETHYLATED_CPG       'z'   /**< Unmethylated C in CpG context */
#define XM_METHYLATED_CPG         'Z'   /**< Methylated C in CpG context */
#define XM_UNMETHYLATED_CHG       'x'   /**< Unmethylated C in CHG context */
#define XM_METHYLATED_CHG         'X'   /**< Methylated C in CHG context */
#define XM_UNMETHYLATED_CHH       'h'   /**< Unmethylated C in CHH context */
#define XM_METHYLATED_CHH         'H'   /**< Methylated C in CHH context */
#define XM_UNMETHYLATED_MUT       'm'   /**< Unmethylated C in MUT context */
#define XM_METHYLATED_MUT         'M'   /**< Methylated C in MUT context */
#define XM_NON_RELEVANT           '.'   /**< Non-relevant or base different from C */

// Values for the Bismark SAM format read transformation
#define XG_CONVERSION_CT          "CT"
#define XG_CONVERSION_GA          "GA"
#define XR_CONVERSION_CT          "CT"
#define XR_CONVERSION_GA          "GA"

/**
  * bam_tag_t structure
  *
  * - Holds the name, type and data for a single BAM tag. A new tag can be created using
  *   the bam_tag_init() function and destroyed using bam_tag_free(). When parsing a BAM
  *   tag string, the generated tags must be freed.
  *
  *   To insert or access the data inside the BAM tag, use the available functions depending
  *   on the internal data type. 
  */
typedef struct bam_tag {
  char tag[3]; /**< Tag name */
  char type;   /**< Tag data type */
  void *data;  /**< Pointer to the tag data */
} bam_tag_t;

/**
 * @brief  Initialize a new BAM tag.
 * @param  tag            Two character name of the BAM tag.
 * @param  type           BAM type.
 * @param  array_type     If the BAM type is binary array, this sets the
 *                        internal type of the data. Otherwise, it is ignored
 * @param  length         If the BAM type is an array type (string, hex or binary),
 *                        this sets the length of the vector to be allocated. Otherwise,
 *                        it is ignored.
 * 
 */
bam_tag_t* bam_tag_init(const char *tag, char type, char array_type, size_t length);

/**
 * @brief  Deallocate a BAM tag.
 * @param  tag_p    Pointer to the BAM tag
 * 
 */
void bam_tag_free(bam_tag_t *tag_p);

/**
 * @brief  Insert a scalar value on a BAM tag.
 * @param  tag_p    Pointer to the BAM tag
 * @param  data     Pointer to the scalar data.
 * 
 * The function checks the internal type of the BAM tag, and assumes that the data
 * passed as an argument holds the same type and size. If a different type is passed
 * (for example, if you try to insert a bam_int_t inside a tag with a bam_byte_t
 * internal format), a buffer overrun may happen.
 */
void bam_tag_set_scalar(bam_tag_t *tag_p, void *data);

/**
 * @brief  Fetch a character value from a BAM tag.
 * @param  tag_p    Pointer to the BAM tag
 * @return          Retrieved character    
 * 
 * The function checks the internal type of the BAM tag, and assumes that the data
 * passed as an argument holds the same type and size. If a different type is passed
 * (for example, if you try to retrieve a bam_char_t from a tag with a bam_int_t
 * internal format), a buffer overrun may happen.
 */
bam_char_t bam_tag_get_char(bam_tag_t *tag_p);

/**
 * @brief  Fetch a byte value from a BAM tag.
 * @param  tag_p    Pointer to the BAM tag
 * @return          Retrieved byte    
 * 
 * The function checks the internal type of the BAM tag, and assumes that the data
 * passed as an argument holds the same type and size. If a different type is passed
 * (for example, if you try to retrieve a bam_byte_t from a tag with a bam_int_t
 * internal format), a buffer overrun may happen.
 */
bam_byte_t bam_tag_get_byte(bam_tag_t *tag_p);

/**
 * @brief  Fetch an unsigned byte value from a BAM tag.
 * @param  tag_p    Pointer to the BAM tag
 * @return          Retrieved unsigned byte    
 * 
 * The function checks the internal type of the BAM tag, and assumes that the data
 * passed as an argument holds the same type and size. If a different type is passed
 * (for example, if you try to retrieve a bam_ubyte_t from a tag with a bam_int_t
 * internal format), a buffer overrun may happen.
 */
bam_ubyte_t bam_tag_get_ubyte(bam_tag_t *tag_p);

/**
 * @brief  Fetch an integer value from a BAM tag.
 * @param  tag_p    Pointer to the BAM tag
 * @return          Retrieved integer   
 * 
 * The function checks the internal type of the BAM tag, and assumes that the data
 * passed as an argument holds the same type and size. If a different type is passed
 * (for example, if you try to retrieve a bam_int_t from a tag with a bam_byte_t
 * internal format), a buffer overrun may happen.
 */
bam_int_t bam_tag_get_int(bam_tag_t *tag_p);

/**
 * @brief  Fetch an unsigned integer value from a BAM tag.
 * @param  tag_p    Pointer to the BAM tag
 * @return          Retrieved unsigned integer   
 * 
 * The function checks the internal type of the BAM tag, and assumes that the data
 * passed as an argument holds the same type and size. If a different type is passed
 * (for example, if you try to retrieve a bam_uint_t from a tag with a bam_byte_t
 * internal format), a buffer overrun may happen.
 */
bam_uint_t bam_tag_get_uint(bam_tag_t *tag_p);

/**
 * @brief  Fetch a floating point value from a BAM tag.
 * @param  tag_p    Pointer to the BAM tag
 * @return          Retrieved unsigned integer   
 * 
 * The function checks the internal type of the BAM tag, and assumes that the data
 * passed as an argument holds the same type and size. If a different type is passed
 * (for example, if you try to retrieve a bam_float_t from a tag with a bam_byte_t
 * internal format), a buffer overrun may happen.
 */
bam_float_t bam_tag_get_float(bam_tag_t *tag_p);

/**
 * @brief  Fetch a character string from a BAM tag.
 * @param  tag_p    Pointer to the BAM tag
 * @param  length   Output string length
 * @return          Retrieved character string
 * 
 * The function allocates a new string which must be freed by the caller. If the
 * length parameter is not NULL, the length is stored inside the parameter.
 *
 * It only can be used if the internal type of the BAM tag is bam_string_t.
 * if it isn't, it will fail silently.
 */
char* bam_tag_get_string(bam_tag_t *tag_p, size_t* length);

/**
 * @brief  Append a single character into a BAM tag.
 * @param  ptr    Pointer to the BAM tag
 * @param  c      Character to append.
 * 
 * The function only can be used if the internal type of the BAM tag is bam_string_t.
 * if it isn't, it will fail silently. Also, if the allocated array has been filled,
 * it will also fail silently. Then, ensure that the array has enough space to fit the
 * character before calling.
 */
void bam_tag_str_append(bam_tag_t *ptr, char c);

/**
 * @brief  Insert a complete string into a BAM tag.
 * @param  ptr      Pointer to the BAM tag
 * @param  str      String to insert.
 * @param  length   Length of the input string
 * 
 * This function copies a complete string into the beggining of the tag string,
 * overwriting any existing data.
 *
 * It can only be used if the internal type of the BAM tag is bam_string_t.
 * if it isn't, it will fail silently. Also, the string to be inserted must be able
 * to fit inside the allocated space in the tag. If it doesn't, it will also fail
 * silently.
 */
void bam_tag_str_insert(bam_tag_t *ptr, const char *str, size_t length);

/**
 * @brief  Initialize a string using a reference character.
 * @param  ptr    Pointer to the BAM tag
 * @param  c      Character to use for the initialization.
 * 
 * This function intializes the tag string, using the the character as the
 * default character.
 *
 * It can only be used if the internal type of the BAM tag is bam_string_t.
 * if it isn't, it will fail silently.
 */
void bam_tag_str_clear(bam_tag_t *ptr, char c);

/**
 * @brief  Serialize a tag array into a BAM string.
 * @param  items        Pointer to the array of BAM tags
 * @param  count        Length of the array
 * @param  out_length   Output parameter with the length of the BAM string
 * 
 * This function serializes an array of BAM tags into a BAM string following
 * the SAM format specification. This string can be inserted into an alignment
 * and it will be properly decoded by any SAM/BAM compliant software.
 *
 * The caller is responsible for freeing the returned string.
 */
char* bam_tag_to_string(const bam_tag_t **items, size_t count, size_t *out_length);

/**
 * @brief  Serialize a list of tag objects into a BAM string.
 * @param  items        Pointer to the tag object list
 * @param  out_length   Output parameter with the length of the BAM string
 * 
 * This function serializes an array of BAM tags into a BAM string following
 * the SAM format specification. This string can be inserted into an alignment
 * and it will be properly decoded by any SAM/BAM compliant software.
 *
 * The caller is responsible for freeing the returned string.
 */
char* bam_tag_list_to_string(array_list_t *items, size_t *out_length);

/**
 * @brief  Parse a BAM tag string into an array of BAM tags
 * @param  bam_string   Pointer to the string
 * @param  length       Length of the string
 * @return              Array list with the tag objects
 *
 * This function parses a BAM string following the SAM format specification into
 * a list of BAM tag objects. It should handle any SAM compliant or proprietary
 * tags.
 *
 * The caller is responsible for freeing the returned tag list and tag objects.
 */
array_list_t* bam_string_to_tag(const char* bam_string, size_t length);

#endif // BAM_TAGS_H